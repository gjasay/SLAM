<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/CMakeLists.txt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/CMakeLists.txt" />
              <option name="originalContent" value="cmake_minimum_required(VERSION 3.15)&#10;project(SLAM VERSION 0.1 LANGUAGES CXX)&#10;&#10;set(CMAKE_CXX_STANDARD 17)&#10;set(CMAKE_CXX_STANDARD_REQUIRED ON)&#10;&#10;# ------------------------&#10;# Add submodules include directories&#10;# ------------------------&#10;&#10;# Raylib (assumes you use raylib as source, it has its own CMake)&#10;add_subdirectory(extern/raylib)&#10;&#10;# For jolt and json, they might not have CMake, so just add include dirs&#10;include_directories(&#10;    extern/jolt/include&#10;    extern/json/include&#10;)&#10;&#10;# ------------------------&#10;# Engine Library&#10;# ------------------------&#10;&#10;file(GLOB_RECURSE ENGINE_SOURCES&#10;    engine/src/*.cpp&#10;    engine/include/*.h&#10;)&#10;&#10;add_library(engine STATIC ${ENGINE_SOURCES}&#10;        engine/include/Script.h&#10;        engine/include/ECS.h&#10;        engine/src/Script.cpp&#10;        engine/include/ui/Canvas.h&#10;        engine/src/ui/Canvas.cpp)&#10;&#10;target_include_directories(engine PUBLIC&#10;    engine/include&#10;    extern/raylib/src&#10;    extern/raygui/src&#10;    extern/jolt/include&#10;    extern/json/include&#10;)&#10;&#10;target_link_libraries(engine PUBLIC raylib) # Link raylib to engine if needed&#10;&#10;# ------------------------&#10;# Editor Executable&#10;# ------------------------&#10;&#10;file(GLOB_RECURSE EDITOR_SOURCES&#10;    editor/src/*.cpp&#10;    editor/include/*.h&#10;)&#10;&#10;add_executable(editor ${EDITOR_SOURCES})&#10;&#10;target_include_directories(editor PUBLIC&#10;    editor/include&#10;    engine/include&#10;    extern/raylib/src&#10;    extern/jolt/include&#10;    extern/json/include&#10;)&#10;&#10;target_link_libraries(editor PRIVATE engine raylib)&#10;&#10;# ------------------------&#10;# Optional: set output directories for binaries and libs&#10;# ------------------------&#10;&#10;set_target_properties(engine PROPERTIES&#10;    ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib&#10;)&#10;&#10;set_target_properties(editor PROPERTIES&#10;    RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin&#10;)&#10;" />
              <option name="updatedContent" value="cmake_minimum_required(VERSION 3.15)&#10;project(SLAM VERSION 0.1 LANGUAGES CXX)&#10;&#10;set(CMAKE_CXX_STANDARD 17)&#10;set(CMAKE_CXX_STANDARD_REQUIRED ON)&#10;&#10;# ------------------------&#10;# Add submodules include directories&#10;# ------------------------&#10;&#10;# Raylib (assumes you use raylib as source, it has its own CMake)&#10;add_subdirectory(extern/raylib)&#10;&#10;# For jolt and json, they might not have CMake, so just add include dirs&#10;include_directories(&#10;    extern/jolt/include&#10;    extern/json/include&#10;)&#10;&#10;# ------------------------&#10;# Engine Library&#10;# ------------------------&#10;&#10;file(GLOB_RECURSE ENGINE_SOURCES&#10;    engine/src/*.cpp&#10;    engine/include/*.h&#10;)&#10;&#10;add_library(engine STATIC&#10;    engine/src/Camera.cpp&#10;    engine/src/ECS.cpp&#10;    engine/src/Engine.cpp&#10;    engine/src/Scene.cpp&#10;    engine/src/Script.cpp&#10;    engine/src/ui/Canvas.cpp&#10;    engine/src/ui/UIElement.cpp&#10;    extern/raygui/src/raygui.c&#10;)&#10;&#10;target_include_directories(engine PUBLIC&#10;    engine/include&#10;    extern/raylib/src&#10;    extern/raygui/src&#10;    extern/jolt/include&#10;    extern/json/include&#10;)&#10;&#10;target_link_libraries(engine PUBLIC raylib) # Link raylib to engine if needed&#10;&#10;# ------------------------&#10;# Editor Executable&#10;# ------------------------&#10;&#10;file(GLOB_RECURSE EDITOR_SOURCES&#10;    editor/src/*.cpp&#10;    editor/include/*.h&#10;)&#10;&#10;add_executable(editor ${EDITOR_SOURCES})&#10;&#10;target_include_directories(editor PUBLIC&#10;    editor/include&#10;    engine/include&#10;    extern/raylib/src&#10;    extern/jolt/include&#10;    extern/json/include&#10;)&#10;&#10;target_link_libraries(editor PRIVATE engine raylib)&#10;&#10;# ------------------------&#10;# Optional: set output directories for binaries and libs&#10;# ------------------------&#10;&#10;set_target_properties(engine PROPERTIES&#10;    ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib&#10;)&#10;&#10;set_target_properties(editor PROPERTIES&#10;    RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/engine/include/ui/UIElement.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/engine/include/ui/UIElement.h" />
              <option name="originalContent" value="#pragma once&#10;&#10;#include &lt;raygui.h&gt;&#10;&#10;namespace slam::ui {&#10;  class UIElement {&#10;    &#10;  };&#10;} " />
              <option name="updatedContent" value="#pragma once&#10;&#10;#include &lt;raygui.h&gt;&#10;#include &lt;vector&gt;&#10;#include &lt;memory&gt;&#10;&#10;namespace slam::ui {&#10;  class UIElement {&#10;  public:&#10;    UIElement() = default;&#10;    virtual ~UIElement() = default;&#10;&#10;    // Add a child element&#10;    void AddChild(std::unique_ptr&lt;UIElement&gt; child) {&#10;      children.emplace_back(std::move(child));&#10;    }&#10;&#10;    // Draw this element and its children&#10;    virtual void Draw() {&#10;      for (auto&amp; child : children) {&#10;        child-&gt;Draw();&#10;      }&#10;    }&#10;&#10;    // Optionally override for layout logic&#10;    virtual void Layout() {}&#10;&#10;  protected:&#10;    std::vector&lt;std::unique_ptr&lt;UIElement&gt;&gt; children;&#10;  };&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/engine/src/Engine.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/engine/src/Engine.cpp" />
              <option name="originalContent" value="#include &quot;../include/Engine.h&quot;&#10;#include &lt;iostream&gt;&#10;&#10;namespace slam {&#10;&#9;void Engine::SetScene(std::unique_ptr&lt;Scene&gt; scene) {&#10;&#9;&#9;if (!scene) {&#10;&#9;&#9;&#9;std::cerr &lt;&lt; &quot;Attempted to set a null Scene!&quot; &lt;&lt; std::endl;&#10;&#9;&#9;&#9;return;&#10;&#9;&#9;}&#10;&#10;&#9;&#9;m_activeScenes.clear();&#10;&#9;&#9;m_sceneMap.clear();&#10;&#10;&#9;&#9;_stageScene(std::move(scene));&#10;&#9;}&#10;&#10;&#9;void Engine::AddScene(std::unique_ptr&lt;Scene&gt; scene) {&#10;&#9;&#9;if (!scene) { std::cerr &lt;&lt; &quot;Attempted to add a null Scene!&quot; &lt;&lt; std::endl; return; }&#10;&#10;&#9;&#9;if (m_sceneMap.find(scene-&gt;Name) != m_sceneMap.end()) {&#10;&#9;&#9;&#9;std::cerr &lt;&lt; &quot;Scene with name '&quot; &lt;&lt; scene-&gt;Name &lt;&lt; &quot;' already exists!&quot; &lt;&lt; std::endl;&#10;&#9;&#9;}&#10;&#10;&#9;&#9;_stageScene(std::move(scene));&#10;&#9;}&#10;&#10;&#9;void Engine::RemoveScene(Scene* scene) {&#10;&#9;&#9;if (!scene) {&#10;&#9;&#9;&#9;std::cerr &lt;&lt; &quot;Attempted to remove a null Scene!&quot; &lt;&lt; std::endl;&#10;&#9;&#9;&#9;return;&#10;&#9;&#9;}&#10;&#10;&#9;&#9;m_scenesToRemove.push_back(scene);&#10;&#9;}&#10;&#10;&#9;void Engine::Run() {&#10;&#9;&#9;std::cout &lt;&lt; &quot;SLAM Application Started!&quot; &lt;&lt; std::endl;&#10;&#10;&#9;&#9;while (!WindowShouldClose()) {&#10;&#9;&#9;&#9;float dt = GetFrameTime();&#10;&#9;&#9;&#9;if (m_activeScenes.size() &gt; 0) {&#10;&#9;&#9;&#9;&#9;for (auto&amp; scene : m_activeScenes) {&#10;&#9;&#9;&#9;&#9;&#9;if (scene) {&#10;&#9;&#9;&#9;&#9;&#9;&#9;scene-&gt;_update(dt);&#10;&#9;&#9;&#9;&#9;&#9;&#9;scene-&gt;_render();&#10;&#9;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;BeginDrawing();&#10;&#9;&#9;&#9;&#9;ClearBackground(RAYWHITE);&#10;&#9;&#9;&#9;&#9;for (auto&amp; scene : m_activeScenes) {&#10;&#9;&#9;&#9;&#9;&#9;if (scene) {&#10;&#9;&#9;&#9;&#9;&#9;&#9;scene-&gt;_draw();&#10;&#9;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;EndDrawing();&#10;&#9;&#9;&#9;&#9;_cleanupRemovedScenes();&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;else {&#10;&#9;&#9;&#9;&#9;std::cerr &lt;&lt; &quot;No active scenes to render!&quot; &lt;&lt; std::endl;&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;&#9;CloseWindow();&#10;&#9;}&#10;&#10;&#9;void Engine::_stageScene(std::unique_ptr&lt;Scene&gt; scene) {&#10;&#9;&#9;scene-&gt;_setEngine(this);&#10;&#9;&#9;m_sceneMap[scene-&gt;Name] = scene.get();&#10;&#9;&#9;m_activeScenes.push_back(std::move(scene));&#10;&#9;&#9;m_activeScenes.back()-&gt;_enter();&#10;&#9;}&#10;&#10;&#10;&#9;void Engine::_cleanupRemovedScenes() {&#10;&#9;&#9;for (Scene* toRemove : m_scenesToRemove) {&#10;&#9;&#9;&#9;for (auto it = m_activeScenes.begin(); it != m_activeScenes.end(); ++it) {&#10;&#9;&#9;&#9;&#9;if (it-&gt;get() == toRemove) {&#10;&#9;&#9;&#9;&#9;&#9;m_sceneMap.erase(it-&gt;get()-&gt;Name);&#10;&#9;&#9;&#9;&#9;&#9;m_activeScenes.erase(it);&#10;&#9;&#9;&#9;&#9;&#9;break;&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;&#9;m_scenesToRemove.clear();&#10;&#9;}&#10;}&#10;" />
              <option name="updatedContent" value="#include &quot;../include/Engine.h&quot;&#10;#include &lt;iostream&gt;&#10;&#10;namespace slam {&#10;&#9;void Engine::SetScene(std::unique_ptr&lt;Scene&gt; scene) {&#10;&#9;&#9;if (!scene) {&#10;&#9;&#9;&#9;std::cerr &lt;&lt; &quot;Attempted to set a null Scene!&quot; &lt;&lt; std::endl;&#10;&#9;&#9;&#9;return;&#10;&#9;&#9;}&#10;&#10;&#9;&#9;m_activeScenes.clear();&#10;&#9;&#9;m_sceneMap.clear();&#10;&#10;&#9;&#9;_stageScene(std::move(scene));&#10;&#9;}&#10;&#10;&#9;void Engine::AddScene(std::unique_ptr&lt;Scene&gt; scene) {&#10;&#9;&#9;if (!scene) { std::cerr &lt;&lt; &quot;Attempted to add a null Scene!&quot; &lt;&lt; std::endl; return; }&#10;&#10;&#9;&#9;if (m_sceneMap.find(scene-&gt;Name) != m_sceneMap.end()) {&#10;&#9;&#9;&#9;std::cerr &lt;&lt; &quot;Scene with name '&quot; &lt;&lt; scene-&gt;Name &lt;&lt; &quot;' already exists!&quot; &lt;&lt; std::endl;&#10;&#9;&#9;}&#10;&#10;&#9;&#9;_stageScene(std::move(scene));&#10;&#9;}&#10;&#10;&#9;void Engine::RemoveScene(Scene* scene) {&#10;&#9;&#9;if (!scene) {&#10;&#9;&#9;&#9;std::cerr &lt;&lt; &quot;Attempted to remove a null Scene!&quot; &lt;&lt; std::endl;&#10;&#9;&#9;&#9;return;&#10;&#9;&#9;}&#10;&#10;&#9;&#9;m_scenesToRemove.push_back(scene);&#10;&#9;}&#10;&#10;&#9;void Engine::Run() {&#10;&#9;&#9;std::cout &lt;&lt; &quot;SLAM Application Started!&quot; &lt;&lt; std::endl;&#10;&#10;&#9;&#9;while (!WindowShouldClose()) {&#10;&#9;&#9;&#9;float dt = GetFrameTime();&#10;&#9;&#9;&#9;if (m_activeScenes.size() &gt; 0) {&#10;&#9;&#9;&#9;&#9;for (auto&amp; scene : m_activeScenes) {&#10;&#9;&#9;&#9;&#9;&#9;if (scene) {&#10;&#9;&#9;&#9;&#9;&#9;&#9;scene-&gt;_update(dt);&#10;&#9;&#9;&#9;&#9;&#9;&#9;scene-&gt;_render();&#10;&#9;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;BeginDrawing();&#10;&#9;&#9;&#9;&#9;ClearBackground(RAYWHITE);&#10;&#9;&#9;&#9;&#9;for (auto&amp; scene : m_activeScenes) {&#10;&#9;&#9;&#9;&#9;&#9;if (scene) {&#10;&#9;&#9;&#9;&#9;&#9;&#9;scene-&gt;_draw();&#10;&#9;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;EndDrawing();&#10;&#9;&#9;&#9;&#9;_cleanupRemovedScenes();&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;else {&#10;&#9;&#9;&#9;&#9;std::cerr &lt;&lt; &quot;No active scenes to render!&quot; &lt;&lt; std::endl;&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;&#9;CloseWindow();&#10;&#9;}&#10;&#10;&#9;void Engine::_stageScene(std::unique_ptr&lt;Scene&gt; scene) {&#10;&#9;&#9;scene-&gt;_setEngine(this);&#10;&#9;&#9;m_sceneMap[scene-&gt;Name] = scene.get();&#10;&#9;&#9;m_activeScenes.push_back(std::move(scene));&#10;&#9;&#9;m_activeScenes.back()-&gt;_enter();&#10;&#9;}&#10;&#10;&#10;&#9;void Engine::_cleanupRemovedScenes() {&#10;&#9;&#9;for (Scene* toRemove : m_scenesToRemove) {&#10;&#9;&#9;&#9;for (auto it = m_activeScenes.begin(); it != m_activeScenes.end(); ++it) {&#10;&#9;&#9;&#9;&#9;if (it-&gt;get() == toRemove) {&#10;&#9;&#9;&#9;&#9;&#9;m_sceneMap.erase(it-&gt;get()-&gt;Name);&#10;&#9;&#9;&#9;&#9;&#9;m_activeScenes.erase(it);&#10;&#9;&#9;&#9;&#9;&#9;break;&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;&#9;m_scenesToRemove.clear();&#10;&#9;}&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/engine/src/ui/Canvas.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/engine/src/ui/Canvas.cpp" />
              <option name="originalContent" value="#include &quot;ui/Canvas.h&quot;&#10;&#10;#include &lt;algorithm&gt;&#10;&#10;namespace slam::ui {&#10;  void Canvas::AddElement(std::unique_ptr&lt;UIElement&gt; element) {&#10;    elements.emplace_back(std::move(element));&#10;  }&#10;&#10;  void Canvas::RemoveElement(UIElement* element) {&#10;    &#10;  }&#10;&#10;}&#10;" />
              <option name="updatedContent" value="#include &quot;ui/Canvas.h&quot;&#10;&#10;#include &lt;algorithm&gt;&#10;&#10;namespace slam::ui {&#10;  void Canvas::AddElement(std::unique_ptr&lt;UIElement&gt; element) {&#10;    elements.emplace_back(std::move(element));&#10;  }&#10;&#10;  void Canvas::RemoveElement(UIElement* element) {&#10;    auto it = std::remove_if(elements.begin(), elements.end(),&#10;      [element](const std::unique_ptr&lt;UIElement&gt;&amp; ptr) {&#10;        return ptr.get() == element;&#10;      });&#10;    elements.erase(it, elements.end());&#10;  }&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>